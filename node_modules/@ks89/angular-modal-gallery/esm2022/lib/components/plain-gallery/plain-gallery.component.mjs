/*
 The MIT License (MIT)

 Copyright (c) 2017-2024 Stefano Cappa (Ks89)

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */
import { ChangeDetectionStrategy, Component, EventEmitter, Input, Output } from '@angular/core';
import { GridLayout, LineLayout, PlainGalleryStrategy } from '../../model/plain-gallery-config.interface';
import { getIndex } from '../../utils/image.util';
import { NEXT } from '../../utils/user-input.util';
import { AccessibleComponent } from '../accessible.component';
import * as i0 from "@angular/core";
import * as i1 from "../../services/config.service";
import * as i2 from "@angular/common";
import * as i3 from "../../directives/size.directive";
import * as i4 from "../../directives/wrap.directive";
import * as i5 from "../../directives/direction.directive";
import * as i6 from "../../directives/a-tag-bg-image.directive";
import * as i7 from "../../directives/fallback-image.directive";
/**
 * Component with the gallery of thumbs.
 * In receives an array of Images, a boolean to show/hide
 * the gallery (feature used by imagePointer) and a config
 * object to customize the behaviour of this component.
 * Also, it emits click events as outputs.
 */
export class PlainGalleryComponent extends AccessibleComponent {
    constructor(configService) {
        super();
        this.configService = configService;
        /**
         * Array of `Image` that represent the model of this library with all images, thumbs and so on.
         */
        this.images = [];
        /**
         * Output to emit an event when an image is clicked.
         */
        this.clickImage = new EventEmitter();
        /**
         * Bi-dimensional array of `Image` object to store images to display as plain gallery.
         * [] by default.
         */
        this.imageGrid = [];
        /**
         * Boolean passed as input to `ks-wrap` directive to configure flex-wrap css property.
         * However it's not enough, because you need to limit the width using `widthStyle` public variable.
         * For more info check https://developer.mozilla.org/it/docs/Web/CSS/flex-wrap
         */
        this.wrapStyle = false;
        /**
         * String passed as input to `ks-wrap` directive to set width to be able to force overflow.
         * In this way, `wrapStyle` (flex-wrap css property) will be used as requested.
         */
        this.widthStyle = '';
    }
    /**
     * Method ´ngOnInit´ to init both `configPlainGallery` calling `initPlainGalleryConfig()`
     * and `imageGrid invoking `initImageGrid()`.
     * This is an angular lifecycle hook, so its called automatically by Angular itself.
     * In particular, it's called only one time!!!
     */
    ngOnInit() {
        if (this.id === null || this.id === undefined) {
            throw new Error('Internal library error - id must be defined');
        }
        this.configService.setConfig(this.id, this.config);
        const libConfig = this.configService.getConfig(this.id);
        if (!libConfig) {
            throw new Error('Internal library error - libConfig must be defined');
        }
        this.accessibilityConfig = libConfig.accessibilityConfig;
        this.plainGalleryConfig = libConfig.plainGalleryConfig;
        this.initImageGrid();
    }
    /**
     * Method ´ngOnChanges´ to update both `imageGrid` and`plainGalleryConfig`.
     * This is an angular lifecycle hook, so its called automatically by Angular itself.
     * In particular, it's called when any data-bound property of a directive changes!!!
     */
    ngOnChanges(changes) {
        if (this.id === null || this.id === undefined) {
            throw new Error('Internal library error - id must be defined');
        }
        const libConfig = this.configService.getConfig(this.id);
        if (!libConfig) {
            throw new Error('Internal library error - libConfig must be defined');
        }
        const imagesChange = changes.images;
        const configChange = changes.config;
        // I'm using !change.firstChange because the first time will be called both onInit and onChange and I don't
        // want to execute initialization two times.
        if (configChange &&
            !configChange.firstChange &&
            (configChange.previousValue !== configChange.currentValue || (!configChange.previousValue && !configChange.currentValue))) {
            this.plainGalleryConfig = libConfig.plainGalleryConfig;
            // this.configPlainGallery = this.initPlainGalleryConfig();
        }
        if (imagesChange && !imagesChange.firstChange && imagesChange.previousValue !== imagesChange.currentValue) {
            this.initImageGrid();
        }
    }
    /**
     * Method called when you click on an image of the plain (or inline) gallery.
     * This will emit the show event with the image as payload.
     * @param Image img is the Image to show
     */
    showModalGalleryByImage(img) {
        const index = this.images.findIndex((val) => val && img && val.id === img.id);
        this.showModalGallery(index);
    }
    /**
     * Method called when you navigate between images.
     * This will emit the show event with the image as payload.
     * @param KeyboardEvent event that triggered the navigation
     * @param Image img is the Image to show
     */
    onNavigationEvent(event, img) {
        const result = super.handleImageEvent(event);
        if (result === NEXT) {
            this.showModalGalleryByImage(img);
        }
    }
    /**
     * Method to get `alt attribute`.
     * `alt` specifies an alternate text for an image, if the image cannot be displayed.
     * @param Image image to get its alt description.
     * @returns string alt description of the image
     */
    getAltPlainDescriptionByImage(image) {
        if (!image) {
            return '';
        }
        return image.plain && image.plain.description ? image.plain.description : `Image ${getIndex(image, this.images) + 1}`;
    }
    /**
     * Method to get the title for an image.
     * @param Image image to get its title
     * @returns string the title of the input image
     */
    getTitleDisplay(image) {
        let description = '';
        if (image.plain && image.plain.description) {
            description = image.plain.description;
        }
        else if (image.modal && image.modal.description) {
            description = image.modal.description;
        }
        const currentIndex = getIndex(image, this.images);
        const prevDescription = 'Image ' + (currentIndex + 1) + '/' + this.images.length;
        let currImgDescription = description ? description : '';
        if (currImgDescription !== '') {
            currImgDescription = ' - ' + currImgDescription;
        }
        return prevDescription + currImgDescription;
    }
    /**
     * Method used in the template to track ids in ngFor.
     * @param number index of the array
     * @param Image item of the array
     * @returns number the id of the item
     */
    trackById(index, item) {
        return item.id;
    }
    /**
     * Method called when you click on an image of the plain (or inline) gallery.
     * This will emit the show event with the index number as payload.
     * @param number index of the clicked image
     */
    showModalGallery(index) {
        this.clickImage.emit(index);
    }
    /**
     * Private method to init both `imageGrid` and other style variables,
     * based on the layout type.
     */
    initImageGrid() {
        if (!this.plainGalleryConfig) {
            throw new Error('Internal library error - plainGalleryConfig must be defined');
        }
        // reset the array to prevent issues in case of GridLayout
        this.imageGrid = [];
        if (this.plainGalleryConfig.layout instanceof LineLayout) {
            const layout = this.plainGalleryConfig.layout;
            const row = this.images.filter((val, i) => i < layout.breakConfig.length || layout.breakConfig.length === -1);
            this.imageGrid = [row];
            this.size = this.plainGalleryConfig.layout.size;
            switch (this.plainGalleryConfig.strategy) {
                case PlainGalleryStrategy.ROW:
                    this.directionStyle = 'row';
                    break;
                case PlainGalleryStrategy.COLUMN:
                    this.directionStyle = 'column';
                    this.wrapStyle = layout.breakConfig.wrap;
                    break;
            }
            this.justifyStyle = layout.justify;
        }
        if (this.plainGalleryConfig.layout instanceof GridLayout) {
            const layout = this.plainGalleryConfig.layout;
            const count = Math.ceil(this.images.length / layout.breakConfig.length);
            let start = 0;
            let end = layout.breakConfig.length - 1;
            for (let j = 0; j < count; j++) {
                const row = this.images.filter((val, i) => i >= start && i <= end);
                this.imageGrid.push(row);
                start = end + 1;
                end = start + layout.breakConfig.length - 1;
            }
            this.size = this.plainGalleryConfig.layout.size;
            const pixels = +layout.size.width.replace('px', '');
            this.widthStyle = pixels * layout.breakConfig.length + pixels / 2 + 'px';
            this.wrapStyle = layout.breakConfig.wrap;
            this.directionStyle = 'row';
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: PlainGalleryComponent, deps: [{ token: i1.ConfigService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.0.1", type: PlainGalleryComponent, selector: "ks-plain-gallery", inputs: { id: "id", images: "images", config: "config" }, outputs: { clickImage: "clickImage" }, usesInheritance: true, usesOnChanges: true, ngImport: i0, template: "<div class=\"plain-container\"\n     ksWrap [wrap]=\"wrapStyle\" [width]=\"widthStyle\"\n     ksDirection [direction]=\"directionStyle\" [justify]=\"justifyStyle\"\n     [attr.aria-label]=\"accessibilityConfig?.plainGalleryContentAriaLabel\"\n     [title]=\"accessibilityConfig?.plainGalleryContentTitle\">\n\n  <ng-container *ngFor=\"let imgRow of imageGrid; let i = index\">\n    <ng-container *ngFor=\"let imgCol of imgRow; let j = index\">\n\n      <ng-container *ngIf=\"!plainGalleryConfig?.advanced?.aTags; else aTags\">\n        <img *ngIf=\"imgCol?.modal?.img\"\n             [loading]=\"imgCol.loading\"\n             [attr.fetchpriority]=\"imgCol.fetchpriority\"\n             [src]=\"imgCol.plain?.img! ? imgCol.plain?.img! : imgCol.modal.img\"\n             ksFallbackImage [fallbackImg]=\"imgCol.plain?.fallbackImg ? imgCol.plain?.fallbackImg : imgCol.modal.fallbackImg\"\n             class=\"image\"\n             ksSize [sizeConfig]=\"{width: size?.width!, height: size?.height!}\"\n             [attr.aria-label]=\"imgCol.plain?.ariaLabel\"\n             [title]=\"(imgCol.plain?.title || imgCol.plain?.title === '') ? imgCol.plain?.title : getTitleDisplay(imgCol)\"\n             alt=\"{{imgCol.plain?.alt! ? imgCol.plain?.alt! : getAltPlainDescriptionByImage(imgCol)}}\"\n             [tabIndex]=\"0\" role=\"img\"\n             (click)=\"showModalGalleryByImage(imgCol)\" (keyup)=\"onNavigationEvent($event, imgCol)\"/>\n      </ng-container>\n\n      <!-- Add directive to set background with the image url as param to pass thumb or img-->\n      <!-- to do something like this <a style=\"background: url('path to image') 50% 50%/cover\">.-->\n      <ng-template #aTags>\n        <a *ngIf=\"imgCol?.modal?.img\"\n           class=\"a-tag-image\"\n           ksATagBgImage [image]=\"imgCol\" [style]=\"plainGalleryConfig?.advanced?.additionalBackground\"\n           ksSize [sizeConfig]=\"{width: size?.width!, height: size?.height!}\"\n           [attr.aria-label]=\"imgCol.plain?.ariaLabel\"\n           [title]=\"(imgCol.plain?.title || imgCol.plain?.title === '') ? imgCol.plain?.title : getTitleDisplay(imgCol)\"\n           [tabIndex]=\"0\"\n           (click)=\"showModalGalleryByImage(imgCol)\" (keyup)=\"onNavigationEvent($event, imgCol)\"></a>\n      </ng-template>\n\n    </ng-container>\n  </ng-container>\n\n</div>\n\n", styles: [".plain-container{align-items:center;display:flex}.plain-container .image{cursor:pointer;height:auto;margin:2px;width:50px}.plain-container .a-tag-image{cursor:pointer;margin:2px}\n"], dependencies: [{ kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.SizeDirective, selector: "[ksSize]", inputs: ["sizeConfig"] }, { kind: "directive", type: i4.WrapDirective, selector: "[ksWrap]", inputs: ["wrap", "width"] }, { kind: "directive", type: i5.DirectionDirective, selector: "[ksDirection]", inputs: ["direction", "justify"] }, { kind: "directive", type: i6.ATagBgImageDirective, selector: "[ksATagBgImage]", inputs: ["image", "style"] }, { kind: "directive", type: i7.FallbackImageDirective, selector: "[ksFallbackImage]", inputs: ["fallbackImg"], outputs: ["fallbackApplied"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: PlainGalleryComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ks-plain-gallery', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div class=\"plain-container\"\n     ksWrap [wrap]=\"wrapStyle\" [width]=\"widthStyle\"\n     ksDirection [direction]=\"directionStyle\" [justify]=\"justifyStyle\"\n     [attr.aria-label]=\"accessibilityConfig?.plainGalleryContentAriaLabel\"\n     [title]=\"accessibilityConfig?.plainGalleryContentTitle\">\n\n  <ng-container *ngFor=\"let imgRow of imageGrid; let i = index\">\n    <ng-container *ngFor=\"let imgCol of imgRow; let j = index\">\n\n      <ng-container *ngIf=\"!plainGalleryConfig?.advanced?.aTags; else aTags\">\n        <img *ngIf=\"imgCol?.modal?.img\"\n             [loading]=\"imgCol.loading\"\n             [attr.fetchpriority]=\"imgCol.fetchpriority\"\n             [src]=\"imgCol.plain?.img! ? imgCol.plain?.img! : imgCol.modal.img\"\n             ksFallbackImage [fallbackImg]=\"imgCol.plain?.fallbackImg ? imgCol.plain?.fallbackImg : imgCol.modal.fallbackImg\"\n             class=\"image\"\n             ksSize [sizeConfig]=\"{width: size?.width!, height: size?.height!}\"\n             [attr.aria-label]=\"imgCol.plain?.ariaLabel\"\n             [title]=\"(imgCol.plain?.title || imgCol.plain?.title === '') ? imgCol.plain?.title : getTitleDisplay(imgCol)\"\n             alt=\"{{imgCol.plain?.alt! ? imgCol.plain?.alt! : getAltPlainDescriptionByImage(imgCol)}}\"\n             [tabIndex]=\"0\" role=\"img\"\n             (click)=\"showModalGalleryByImage(imgCol)\" (keyup)=\"onNavigationEvent($event, imgCol)\"/>\n      </ng-container>\n\n      <!-- Add directive to set background with the image url as param to pass thumb or img-->\n      <!-- to do something like this <a style=\"background: url('path to image') 50% 50%/cover\">.-->\n      <ng-template #aTags>\n        <a *ngIf=\"imgCol?.modal?.img\"\n           class=\"a-tag-image\"\n           ksATagBgImage [image]=\"imgCol\" [style]=\"plainGalleryConfig?.advanced?.additionalBackground\"\n           ksSize [sizeConfig]=\"{width: size?.width!, height: size?.height!}\"\n           [attr.aria-label]=\"imgCol.plain?.ariaLabel\"\n           [title]=\"(imgCol.plain?.title || imgCol.plain?.title === '') ? imgCol.plain?.title : getTitleDisplay(imgCol)\"\n           [tabIndex]=\"0\"\n           (click)=\"showModalGalleryByImage(imgCol)\" (keyup)=\"onNavigationEvent($event, imgCol)\"></a>\n      </ng-template>\n\n    </ng-container>\n  </ng-container>\n\n</div>\n\n", styles: [".plain-container{align-items:center;display:flex}.plain-container .image{cursor:pointer;height:auto;margin:2px;width:50px}.plain-container .a-tag-image{cursor:pointer;margin:2px}\n"] }]
        }], ctorParameters: () => [{ type: i1.ConfigService }], propDecorators: { id: [{
                type: Input
            }], images: [{
                type: Input
            }], config: [{
                type: Input
            }], clickImage: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGxhaW4tZ2FsbGVyeS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9rczg5L2FuZ3VsYXItbW9kYWwtZ2FsbGVyeS9zcmMvbGliL2NvbXBvbmVudHMvcGxhaW4tZ2FsbGVyeS9wbGFpbi1nYWxsZXJ5LmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2tzODkvYW5ndWxhci1tb2RhbC1nYWxsZXJ5L3NyYy9saWIvY29tcG9uZW50cy9wbGFpbi1nYWxsZXJ5L3BsYWluLWdhbGxlcnkuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXNCRztBQUVILE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBcUIsTUFBTSxFQUErQixNQUFNLGVBQWUsQ0FBQztBQUtoSixPQUFPLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBc0Isb0JBQW9CLEVBQUUsTUFBTSw0Q0FBNEMsQ0FBQztBQUU5SCxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFFbEQsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQ25ELE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLHlCQUF5QixDQUFDOzs7Ozs7Ozs7QUFHOUQ7Ozs7OztHQU1HO0FBT0gsTUFBTSxPQUFPLHFCQUFzQixTQUFRLG1CQUFtQjtJQW1FNUQsWUFBb0IsYUFBNEI7UUFDOUMsS0FBSyxFQUFFLENBQUM7UUFEVSxrQkFBYSxHQUFiLGFBQWEsQ0FBZTtRQTNEaEQ7O1dBRUc7UUFFSCxXQUFNLEdBQVksRUFBRSxDQUFDO1FBT3JCOztXQUVHO1FBRUgsZUFBVSxHQUF5QixJQUFJLFlBQVksRUFBVSxDQUFDO1FBYTlEOzs7V0FHRztRQUNILGNBQVMsR0FBYyxFQUFFLENBQUM7UUFLMUI7Ozs7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QUFDO2dCQUNoQixHQUFHLEdBQUcsS0FBSyxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztZQUM5QyxDQUFDO1lBRUQsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQztZQUVoRCxNQUFNLE1BQU0sR0FBVyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFFNUQsSUFBSSxDQUFDLFVBQVUsR0FBRyxNQUFNLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEdBQUcsTUFBTSxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUM7WUFDekUsSUFBSSxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQztZQUV6QyxJQUFJLENBQUMsY0FBYyxHQUFHLEtBQUssQ0FBQztRQUM5QixDQUFDO0lBQ0gsQ0FBQzs4R0EvUFUscUJBQXFCO2tHQUFyQixxQkFBcUIscU1DbERsQyxpekVBMENBOzsyRkRRYSxxQkFBcUI7a0JBTmpDLFNBQVM7K0JBQ0Usa0JBQWtCLG1CQUdYLHVCQUF1QixDQUFDLE1BQU07a0ZBUS9DLEVBQUU7c0JBREQsS0FBSztnQkFPTixNQUFNO3NCQURMLEtBQUs7Z0JBTU4sTUFBTTtzQkFETCxLQUFLO2dCQU9OLFVBQVU7c0JBRFQsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiBDb3B5cmlnaHQgKGMpIDIwMTctMjAyNCBTdGVmYW5vIENhcHBhIChLczg5KVxuXG4gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT04gSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uQ2hhbmdlcywgT25Jbml0LCBPdXRwdXQsIFNpbXBsZUNoYW5nZSwgU2ltcGxlQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBBY2Nlc3NpYmlsaXR5Q29uZmlnIH0gZnJvbSAnLi4vLi4vbW9kZWwvYWNjZXNzaWJpbGl0eS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSW1hZ2UgfSBmcm9tICcuLi8uLi9tb2RlbC9pbWFnZS5jbGFzcyc7XG5pbXBvcnQgeyBTaXplIH0gZnJvbSAnLi4vLi4vbW9kZWwvc2l6ZS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgR3JpZExheW91dCwgTGluZUxheW91dCwgUGxhaW5HYWxsZXJ5Q29uZmlnLCBQbGFpbkdhbGxlcnlTdHJhdGVneSB9IGZyb20gJy4uLy4uL21vZGVsL3BsYWluLWdhbGxlcnktY29uZmlnLmludGVyZmFjZSc7XG5cbmltcG9ydCB7IGdldEluZGV4IH0gZnJvbSAnLi4vLi4vdXRpbHMvaW1hZ2UudXRpbCc7XG5pbXBvcnQgeyBDb25maWdTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvY29uZmlnLnNlcnZpY2UnO1xuaW1wb3J0IHsgTkVYVCB9IGZyb20gJy4uLy4uL3V0aWxzL3VzZXItaW5wdXQudXRpbCc7XG5pbXBvcnQgeyBBY2Nlc3NpYmxlQ29tcG9uZW50IH0gZnJvbSAnLi4vYWNjZXNzaWJsZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgUGxhaW5MaWJDb25maWcsIExpYkNvbmZpZyB9IGZyb20gJy4uLy4uL21vZGVsL2xpYi1jb25maWcuaW50ZXJmYWNlJztcblxuLyoqXG4gKiBDb21wb25lbnQgd2l0aCB0aGUgZ2FsbGVyeSBvZiB0aHVtYnMuXG4gKiBJbiByZWNlaXZlcyBhbiBhcnJheSBvZiBJbWFnZXMsIGEgYm9vbGVhbiB0byBzaG93L2hpZGVcbiAqIHRoZSBnYWxsZXJ5IChmZWF0dXJlIHVzZWQgYnkgaW1hZ2VQb2ludGVyKSBhbmQgYSBjb25maWdcbiAqIG9iamVjdCB0byBjdXN0b21pemUgdGhlIGJlaGF2aW91ciBvZiB0aGlzIGNvbXBvbmVudC5cbiAqIEFsc28sIGl0IGVtaXRzIGNsaWNrIGV2ZW50cyBhcyBvdXRwdXRzLlxuICovXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdrcy1wbGFpbi1nYWxsZXJ5JyxcbiAgc3R5bGVVcmxzOiBbJ3BsYWluLWdhbGxlcnkuc2NzcyddLFxuICB0ZW1wbGF0ZVVybDogJ3BsYWluLWdhbGxlcnkuaHRtbCcsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIFBsYWluR2FsbGVyeUNvbXBvbmVudCBleHRlbmRzIEFjY2Vzc2libGVDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcyB7XG4gIC8qKlxuICAgKiBVbmlxdWUgaWQgKD49MCkgb2YgdGhlIGN1cnJlbnQgaW5zdGFuY2Ugb2YgdGhpcyBsaWJyYXJ5LiBUaGlzIGlzIHJlcXVpcmVkIHdoZW4geW91IGFyZSB1c2luZ1xuICAgKiB0aGUgc2VydmljZSB0byBjYWxsIG1vZGFsIGdhbGxlcnkuXG4gICAqL1xuICBASW5wdXQoKVxuICBpZDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBBcnJheSBvZiBgSW1hZ2VgIHRoYXQgcmVwcmVzZW50IHRoZSBtb2RlbCBvZiB0aGlzIGxpYnJhcnkgd2l0aCBhbGwgaW1hZ2VzLCB0aHVtYnMgYW5kIHNvIG9uLlxuICAgKi9cbiAgQElucHV0KClcbiAgaW1hZ2VzOiBJbWFnZVtdID0gW107XG4gIC8qKlxuICAgKiBQbGFpbkxpYkNvbmZpZyBvYmplY3QgdG8gY29uZmlndXJlIHBsYWluLWdhbGxlcnkuXG4gICAqL1xuICBASW5wdXQoKVxuICBjb25maWc6IFBsYWluTGliQ29uZmlnIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBPdXRwdXQgdG8gZW1pdCBhbiBldmVudCB3aGVuIGFuIGltYWdlIGlzIGNsaWNrZWQuXG4gICAqL1xuICBAT3V0cHV0KClcbiAgY2xpY2tJbWFnZTogRXZlbnRFbWl0dGVyPG51bWJlcj4gPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblxuICAvKipcbiAgICogT2JqZWN0IG9mIHR5cGUgYFBsYWluR2FsbGVyeUNvbmZpZ2AgdG8gY29uZmlndXJlIHRoZSBwbGFpbiBnYWxsZXJ5LlxuICAgKi9cbiAgcGxhaW5HYWxsZXJ5Q29uZmlnOiBQbGFpbkdhbGxlcnlDb25maWcgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIE9iamVjdCBvZiB0eXBlIGBBY2Nlc3NpYmlsaXR5Q29uZmlnYCB0byBpbml0IGN1c3RvbSBhY2Nlc3NpYmlsaXR5IGZlYXR1cmVzLlxuICAgKiBGb3IgaW5zdGFuY2UsIGl0IGNvbnRhaW5zIHRpdGxlcywgYWx0IHRleHRzLCBhcmlhLWxhYmVscyBhbmQgc28gb24uXG4gICAqL1xuICBhY2Nlc3NpYmlsaXR5Q29uZmlnOiBBY2Nlc3NpYmlsaXR5Q29uZmlnIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBCaS1kaW1lbnNpb25hbCBhcnJheSBvZiBgSW1hZ2VgIG9iamVjdCB0byBzdG9yZSBpbWFnZXMgdG8gZGlzcGxheSBhcyBwbGFpbiBnYWxsZXJ5LlxuICAgKiBbXSBieSBkZWZhdWx0LlxuICAgKi9cbiAgaW1hZ2VHcmlkOiBJbWFnZVtdW10gPSBbXTtcbiAgLyoqXG4gICAqIFNpemUgb2JqZWN0IHVzZWQgaW4gdGhlIHRlbXBsYXRlIHRvIHJlc2l6ZSBpbWFnZXMuXG4gICAqL1xuICBzaXplOiBTaXplIHwgdW5kZWZpbmVkO1xuICAvKipcbiAgICogQm9vbGVhbiBwYXNzZWQgYXMgaW5wdXQgdG8gYGtzLXdyYXBgIGRpcmVjdGl2ZSB0byBjb25maWd1cmUgZmxleC13cmFwIGNzcyBwcm9wZXJ0eS5cbiAgICogSG93ZXZlciBpdCdzIG5vdCBlbm91Z2gsIGJlY2F1c2UgeW91IG5lZWQgdG8gbGltaXQgdGhlIHdpZHRoIHVzaW5nIGB3aWR0aFN0eWxlYCBwdWJsaWMgdmFyaWFibGUuXG4gICAqIEZvciBtb3JlIGluZm8gY2hlY2sgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvaXQvZG9jcy9XZWIvQ1NTL2ZsZXgtd3JhcFxuICAgKi9cbiAgd3JhcFN0eWxlID0gZmFsc2U7XG4gIC8qKlxuICAgKiBTdHJpbmcgcGFzc2VkIGFzIGlucHV0IHRvIGBrcy13cmFwYCBkaXJlY3RpdmUgdG8gc2V0IHdpZHRoIHRvIGJlIGFibGUgdG8gZm9yY2Ugb3ZlcmZsb3cuXG4gICAqIEluIHRoaXMgd2F5LCBgd3JhcFN0eWxlYCAoZmxleC13cmFwIGNzcyBwcm9wZXJ0eSkgd2lsbCBiZSB1c2VkIGFzIHJlcXVlc3RlZC5cbiAgICovXG4gIHdpZHRoU3R5bGUgPSAnJztcbiAgLyoqXG4gICAqIFN0cmluZyBwYXNzZWQgYXMgaW5wdXQgdG8gYGtzLWRpcmVjdGlvbmAgZGlyZWN0aXZlIHRvIHNldCB0aGUgZmxleC1kaXJlY3Rpb24gY3NzIHByb3BlcnR5LlxuICAgKiBGb3IgbW9yZSBpbmZvIGNoZWNrIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2l0L2RvY3MvV2ViL0NTUy9mbGV4LWRpcmVjdGlvblxuICAgKi9cbiAgZGlyZWN0aW9uU3R5bGU6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgLyoqXG4gICAqIFN0cmluZyBwYXNzZWQgYXMgaW5wdXQgdG8gYGtzLWRpcmVjdGlvbmAgZGlyZWN0aXZlIHRvIHNldCB0aGUganVzdGlmeS1jb250ZW50IGNzcyBwcm9wZXJ0eS5cbiAgICogRm9yIG1vcmUgaW5mbyBjaGVjayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9pdC9kb2NzL1dlYi9DU1MvanVzdGlmeS1jb250ZW50XG4gICAqL1xuICBqdXN0aWZ5U3R5bGU6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNvbmZpZ1NlcnZpY2U6IENvbmZpZ1NlcnZpY2UpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCDCtG5nT25Jbml0wrQgdG8gaW5pdCBib3RoIGBjb25maWdQbGFpbkdhbGxlcnlgIGNhbGxpbmcgYGluaXRQbGFpbkdhbGxlcnlDb25maWcoKWBcbiAgICogYW5kIGBpbWFnZUdyaWQgaW52b2tpbmcgYGluaXRJbWFnZUdyaWQoKWAuXG4gICAqIFRoaXMgaXMgYW4gYW5ndWxhciBsaWZlY3ljbGUgaG9vaywgc28gaXRzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGJ5IEFuZ3VsYXIgaXRzZWxmLlxuICAgKiBJbiBwYXJ0aWN1bGFyLCBpdCdzIGNhbGxlZCBvbmx5IG9uZSB0aW1lISEhXG4gICAqL1xuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pZCA9PT0gbnVsbCB8fCB0aGlzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW50ZXJuYWwgbGlicmFyeSBlcnJvciAtIGlkIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgIH1cbiAgICB0aGlzLmNvbmZpZ1NlcnZpY2Uuc2V0Q29uZmlnKHRoaXMuaWQsIHRoaXMuY29uZmlnKTtcblxuICAgIGNvbnN0IGxpYkNvbmZpZzogTGliQ29uZmlnIHwgdW5kZWZpbmVkID0gdGhpcy5jb25maWdTZXJ2aWNlLmdldENvbmZpZyh0aGlzLmlkKTtcbiAgICBpZiAoIWxpYkNvbmZpZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlcm5hbCBsaWJyYXJ5IGVycm9yIC0gbGliQ29uZmlnIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgIH1cbiAgICB0aGlzLmFjY2Vzc2liaWxpdHlDb25maWcgPSBsaWJDb25maWcuYWNjZXNzaWJpbGl0eUNvbmZpZztcbiAgICB0aGlzLnBsYWluR2FsbGVyeUNvbmZpZyA9IGxpYkNvbmZpZy5wbGFpbkdhbGxlcnlDb25maWc7XG4gICAgdGhpcy5pbml0SW1hZ2VHcmlkKCk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIMK0bmdPbkNoYW5nZXPCtCB0byB1cGRhdGUgYm90aCBgaW1hZ2VHcmlkYCBhbmRgcGxhaW5HYWxsZXJ5Q29uZmlnYC5cbiAgICogVGhpcyBpcyBhbiBhbmd1bGFyIGxpZmVjeWNsZSBob29rLCBzbyBpdHMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgQW5ndWxhciBpdHNlbGYuXG4gICAqIEluIHBhcnRpY3VsYXIsIGl0J3MgY2FsbGVkIHdoZW4gYW55IGRhdGEtYm91bmQgcHJvcGVydHkgb2YgYSBkaXJlY3RpdmUgY2hhbmdlcyEhIVxuICAgKi9cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlkID09PSBudWxsIHx8IHRoaXMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlcm5hbCBsaWJyYXJ5IGVycm9yIC0gaWQgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgfVxuICAgIGNvbnN0IGxpYkNvbmZpZzogTGliQ29uZmlnIHwgdW5kZWZpbmVkID0gdGhpcy5jb25maWdTZXJ2aWNlLmdldENvbmZpZyh0aGlzLmlkKTtcbiAgICBpZiAoIWxpYkNvbmZpZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlcm5hbCBsaWJyYXJ5IGVycm9yIC0gbGliQ29uZmlnIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGltYWdlc0NoYW5nZTogU2ltcGxlQ2hhbmdlID0gY2hhbmdlcy5pbWFnZXM7XG4gICAgY29uc3QgY29uZmlnQ2hhbmdlOiBTaW1wbGVDaGFuZ2UgPSBjaGFuZ2VzLmNvbmZpZztcbiAgICAvLyBJJ20gdXNpbmcgIWNoYW5nZS5maXJzdENoYW5nZSBiZWNhdXNlIHRoZSBmaXJzdCB0aW1lIHdpbGwgYmUgY2FsbGVkIGJvdGggb25Jbml0IGFuZCBvbkNoYW5nZSBhbmQgSSBkb24ndFxuICAgIC8vIHdhbnQgdG8gZXhlY3V0ZSBpbml0aWFsaXphdGlvbiB0d28gdGltZXMuXG4gICAgaWYgKFxuICAgICAgY29uZmlnQ2hhbmdlICYmXG4gICAgICAhY29uZmlnQ2hhbmdlLmZpcnN0Q2hhbmdlICYmXG4gICAgICAoY29uZmlnQ2hhbmdlLnByZXZpb3VzVmFsdWUgIT09IGNvbmZpZ0NoYW5nZS5jdXJyZW50VmFsdWUgfHwgKCFjb25maWdDaGFuZ2UucHJldmlvdXNWYWx1ZSAmJiAhY29uZmlnQ2hhbmdlLmN1cnJlbnRWYWx1ZSkpXG4gICAgKSB7XG4gICAgICB0aGlzLnBsYWluR2FsbGVyeUNvbmZpZyA9IGxpYkNvbmZpZy5wbGFpbkdhbGxlcnlDb25maWc7XG4gICAgICAvLyB0aGlzLmNvbmZpZ1BsYWluR2FsbGVyeSA9IHRoaXMuaW5pdFBsYWluR2FsbGVyeUNvbmZpZygpO1xuICAgIH1cbiAgICBpZiAoaW1hZ2VzQ2hhbmdlICYmICFpbWFnZXNDaGFuZ2UuZmlyc3RDaGFuZ2UgJiYgaW1hZ2VzQ2hhbmdlLnByZXZpb3VzVmFsdWUgIT09IGltYWdlc0NoYW5nZS5jdXJyZW50VmFsdWUpIHtcbiAgICAgIHRoaXMuaW5pdEltYWdlR3JpZCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgY2FsbGVkIHdoZW4geW91IGNsaWNrIG9uIGFuIGltYWdlIG9mIHRoZSBwbGFpbiAob3IgaW5saW5lKSBnYWxsZXJ5LlxuICAgKiBUaGlzIHdpbGwgZW1pdCB0aGUgc2hvdyBldmVudCB3aXRoIHRoZSBpbWFnZSBhcyBwYXlsb2FkLlxuICAgKiBAcGFyYW0gSW1hZ2UgaW1nIGlzIHRoZSBJbWFnZSB0byBzaG93XG4gICAqL1xuICBzaG93TW9kYWxHYWxsZXJ5QnlJbWFnZShpbWc6IEltYWdlKTogdm9pZCB7XG4gICAgY29uc3QgaW5kZXg6IG51bWJlciA9IHRoaXMuaW1hZ2VzLmZpbmRJbmRleCgodmFsOiBJbWFnZSkgPT4gdmFsICYmIGltZyAmJiB2YWwuaWQgPT09IGltZy5pZCk7XG4gICAgdGhpcy5zaG93TW9kYWxHYWxsZXJ5KGluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgY2FsbGVkIHdoZW4geW91IG5hdmlnYXRlIGJldHdlZW4gaW1hZ2VzLlxuICAgKiBUaGlzIHdpbGwgZW1pdCB0aGUgc2hvdyBldmVudCB3aXRoIHRoZSBpbWFnZSBhcyBwYXlsb2FkLlxuICAgKiBAcGFyYW0gS2V5Ym9hcmRFdmVudCBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGUgbmF2aWdhdGlvblxuICAgKiBAcGFyYW0gSW1hZ2UgaW1nIGlzIHRoZSBJbWFnZSB0byBzaG93XG4gICAqL1xuICBvbk5hdmlnYXRpb25FdmVudChldmVudDogS2V5Ym9hcmRFdmVudCwgaW1nOiBJbWFnZSk6IHZvaWQge1xuICAgIGNvbnN0IHJlc3VsdDogbnVtYmVyID0gc3VwZXIuaGFuZGxlSW1hZ2VFdmVudChldmVudCk7XG4gICAgaWYgKHJlc3VsdCA9PT0gTkVYVCkge1xuICAgICAgdGhpcy5zaG93TW9kYWxHYWxsZXJ5QnlJbWFnZShpbWcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdG8gZ2V0IGBhbHQgYXR0cmlidXRlYC5cbiAgICogYGFsdGAgc3BlY2lmaWVzIGFuIGFsdGVybmF0ZSB0ZXh0IGZvciBhbiBpbWFnZSwgaWYgdGhlIGltYWdlIGNhbm5vdCBiZSBkaXNwbGF5ZWQuXG4gICAqIEBwYXJhbSBJbWFnZSBpbWFnZSB0byBnZXQgaXRzIGFsdCBkZXNjcmlwdGlvbi5cbiAgICogQHJldHVybnMgc3RyaW5nIGFsdCBkZXNjcmlwdGlvbiBvZiB0aGUgaW1hZ2VcbiAgICovXG4gIGdldEFsdFBsYWluRGVzY3JpcHRpb25CeUltYWdlKGltYWdlOiBJbWFnZSk6IHN0cmluZyB7XG4gICAgaWYgKCFpbWFnZSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gaW1hZ2UucGxhaW4gJiYgaW1hZ2UucGxhaW4uZGVzY3JpcHRpb24gPyBpbWFnZS5wbGFpbi5kZXNjcmlwdGlvbiA6IGBJbWFnZSAke2dldEluZGV4KGltYWdlLCB0aGlzLmltYWdlcykgKyAxfWA7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHRvIGdldCB0aGUgdGl0bGUgZm9yIGFuIGltYWdlLlxuICAgKiBAcGFyYW0gSW1hZ2UgaW1hZ2UgdG8gZ2V0IGl0cyB0aXRsZVxuICAgKiBAcmV0dXJucyBzdHJpbmcgdGhlIHRpdGxlIG9mIHRoZSBpbnB1dCBpbWFnZVxuICAgKi9cbiAgZ2V0VGl0bGVEaXNwbGF5KGltYWdlOiBJbWFnZSk6IHN0cmluZyB7XG4gICAgbGV0IGRlc2NyaXB0aW9uID0gJyc7XG5cbiAgICBpZiAoaW1hZ2UucGxhaW4gJiYgaW1hZ2UucGxhaW4uZGVzY3JpcHRpb24pIHtcbiAgICAgIGRlc2NyaXB0aW9uID0gaW1hZ2UucGxhaW4uZGVzY3JpcHRpb247XG4gICAgfSBlbHNlIGlmIChpbWFnZS5tb2RhbCAmJiBpbWFnZS5tb2RhbC5kZXNjcmlwdGlvbikge1xuICAgICAgZGVzY3JpcHRpb24gPSBpbWFnZS5tb2RhbC5kZXNjcmlwdGlvbjtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJyZW50SW5kZXg6IG51bWJlciA9IGdldEluZGV4KGltYWdlLCB0aGlzLmltYWdlcyk7XG4gICAgY29uc3QgcHJldkRlc2NyaXB0aW9uOiBzdHJpbmcgPSAnSW1hZ2UgJyArIChjdXJyZW50SW5kZXggKyAxKSArICcvJyArIHRoaXMuaW1hZ2VzLmxlbmd0aDtcbiAgICBsZXQgY3VyckltZ0Rlc2NyaXB0aW9uOiBzdHJpbmcgPSBkZXNjcmlwdGlvbiA/IGRlc2NyaXB0aW9uIDogJyc7XG5cbiAgICBpZiAoY3VyckltZ0Rlc2NyaXB0aW9uICE9PSAnJykge1xuICAgICAgY3VyckltZ0Rlc2NyaXB0aW9uID0gJyAtICcgKyBjdXJySW1nRGVzY3JpcHRpb247XG4gICAgfVxuICAgIHJldHVybiBwcmV2RGVzY3JpcHRpb24gKyBjdXJySW1nRGVzY3JpcHRpb247XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHVzZWQgaW4gdGhlIHRlbXBsYXRlIHRvIHRyYWNrIGlkcyBpbiBuZ0Zvci5cbiAgICogQHBhcmFtIG51bWJlciBpbmRleCBvZiB0aGUgYXJyYXlcbiAgICogQHBhcmFtIEltYWdlIGl0ZW0gb2YgdGhlIGFycmF5XG4gICAqIEByZXR1cm5zIG51bWJlciB0aGUgaWQgb2YgdGhlIGl0ZW1cbiAgICovXG4gIHRyYWNrQnlJZChpbmRleDogbnVtYmVyLCBpdGVtOiBJbWFnZSk6IG51bWJlciB7XG4gICAgcmV0dXJuIGl0ZW0uaWQ7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIGNhbGxlZCB3aGVuIHlvdSBjbGljayBvbiBhbiBpbWFnZSBvZiB0aGUgcGxhaW4gKG9yIGlubGluZSkgZ2FsbGVyeS5cbiAgICogVGhpcyB3aWxsIGVtaXQgdGhlIHNob3cgZXZlbnQgd2l0aCB0aGUgaW5kZXggbnVtYmVyIGFzIHBheWxvYWQuXG4gICAqIEBwYXJhbSBudW1iZXIgaW5kZXggb2YgdGhlIGNsaWNrZWQgaW1hZ2VcbiAgICovXG4gIHByaXZhdGUgc2hvd01vZGFsR2FsbGVyeShpbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5jbGlja0ltYWdlLmVtaXQoaW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByaXZhdGUgbWV0aG9kIHRvIGluaXQgYm90aCBgaW1hZ2VHcmlkYCBhbmQgb3RoZXIgc3R5bGUgdmFyaWFibGVzLFxuICAgKiBiYXNlZCBvbiB0aGUgbGF5b3V0IHR5cGUuXG4gICAqL1xuICBwcml2YXRlIGluaXRJbWFnZUdyaWQoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnBsYWluR2FsbGVyeUNvbmZpZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlcm5hbCBsaWJyYXJ5IGVycm9yIC0gcGxhaW5HYWxsZXJ5Q29uZmlnIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgIH1cblxuICAgIC8vIHJlc2V0IHRoZSBhcnJheSB0byBwcmV2ZW50IGlzc3VlcyBpbiBjYXNlIG9mIEdyaWRMYXlvdXRcbiAgICB0aGlzLmltYWdlR3JpZCA9IFtdO1xuXG4gICAgaWYgKHRoaXMucGxhaW5HYWxsZXJ5Q29uZmlnLmxheW91dCBpbnN0YW5jZW9mIExpbmVMYXlvdXQpIHtcbiAgICAgIGNvbnN0IGxheW91dDogTGluZUxheW91dCA9IHRoaXMucGxhaW5HYWxsZXJ5Q29uZmlnLmxheW91dDtcbiAgICAgIGNvbnN0IHJvdzogSW1hZ2VbXSA9IHRoaXMuaW1hZ2VzLmZpbHRlcigodmFsOiBJbWFnZSwgaTogbnVtYmVyKSA9PiBpIDwgbGF5b3V0LmJyZWFrQ29uZmlnLmxlbmd0aCB8fCBsYXlvdXQuYnJlYWtDb25maWcubGVuZ3RoID09PSAtMSk7XG4gICAgICB0aGlzLmltYWdlR3JpZCA9IFtyb3ddO1xuXG4gICAgICB0aGlzLnNpemUgPSB0aGlzLnBsYWluR2FsbGVyeUNvbmZpZy5sYXlvdXQuc2l6ZTtcblxuICAgICAgc3dpdGNoICh0aGlzLnBsYWluR2FsbGVyeUNvbmZpZy5zdHJhdGVneSkge1xuICAgICAgICBjYXNlIFBsYWluR2FsbGVyeVN0cmF0ZWd5LlJPVzpcbiAgICAgICAgICB0aGlzLmRpcmVjdGlvblN0eWxlID0gJ3Jvdyc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUGxhaW5HYWxsZXJ5U3RyYXRlZ3kuQ09MVU1OOlxuICAgICAgICAgIHRoaXMuZGlyZWN0aW9uU3R5bGUgPSAnY29sdW1uJztcbiAgICAgICAgICB0aGlzLndyYXBTdHlsZSA9IGxheW91dC5icmVha0NvbmZpZy53cmFwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGhpcy5qdXN0aWZ5U3R5bGUgPSBsYXlvdXQuanVzdGlmeTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wbGFpbkdhbGxlcnlDb25maWcubGF5b3V0IGluc3RhbmNlb2YgR3JpZExheW91dCkge1xuICAgICAgY29uc3QgbGF5b3V0OiBHcmlkTGF5b3V0ID0gdGhpcy5wbGFpbkdhbGxlcnlDb25maWcubGF5b3V0O1xuICAgICAgY29uc3QgY291bnQ6IG51bWJlciA9IE1hdGguY2VpbCh0aGlzLmltYWdlcy5sZW5ndGggLyBsYXlvdXQuYnJlYWtDb25maWcubGVuZ3RoKTtcbiAgICAgIGxldCBzdGFydCA9IDA7XG4gICAgICBsZXQgZW5kOiBudW1iZXIgPSBsYXlvdXQuYnJlYWtDb25maWcubGVuZ3RoIC0gMTtcblxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgIGNvbnN0IHJvdzogSW1hZ2VbXSA9IHRoaXMuaW1hZ2VzLmZpbHRlcigodmFsOiBJbWFnZSwgaTogbnVtYmVyKSA9PiBpID49IHN0YXJ0ICYmIGkgPD0gZW5kKTtcbiAgICAgICAgdGhpcy5pbWFnZUdyaWQucHVzaChyb3cpO1xuICAgICAgICBzdGFydCA9IGVuZCArIDE7XG4gICAgICAgIGVuZCA9IHN0YXJ0ICsgbGF5b3V0LmJyZWFrQ29uZmlnLmxlbmd0aCAtIDE7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2l6ZSA9IHRoaXMucGxhaW5HYWxsZXJ5Q29uZmlnLmxheW91dC5zaXplO1xuXG4gICAgICBjb25zdCBwaXhlbHM6IG51bWJlciA9ICtsYXlvdXQuc2l6ZS53aWR0aC5yZXBsYWNlKCdweCcsICcnKTtcblxuICAgICAgdGhpcy53aWR0aFN0eWxlID0gcGl4ZWxzICogbGF5b3V0LmJyZWFrQ29uZmlnLmxlbmd0aCArIHBpeGVscyAvIDIgKyAncHgnO1xuICAgICAgdGhpcy53cmFwU3R5bGUgPSBsYXlvdXQuYnJlYWtDb25maWcud3JhcDtcblxuICAgICAgdGhpcy5kaXJlY3Rpb25TdHlsZSA9ICdyb3cnO1xuICAgIH1cbiAgfVxufVxuIiwiPGRpdiBjbGFzcz1cInBsYWluLWNvbnRhaW5lclwiXG4gICAgIGtzV3JhcCBbd3JhcF09XCJ3cmFwU3R5bGVcIiBbd2lkdGhdPVwid2lkdGhTdHlsZVwiXG4gICAgIGtzRGlyZWN0aW9uIFtkaXJlY3Rpb25dPVwiZGlyZWN0aW9uU3R5bGVcIiBbanVzdGlmeV09XCJqdXN0aWZ5U3R5bGVcIlxuICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImFjY2Vzc2liaWxpdHlDb25maWc/LnBsYWluR2FsbGVyeUNvbnRlbnRBcmlhTGFiZWxcIlxuICAgICBbdGl0bGVdPVwiYWNjZXNzaWJpbGl0eUNvbmZpZz8ucGxhaW5HYWxsZXJ5Q29udGVudFRpdGxlXCI+XG5cbiAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgaW1nUm93IG9mIGltYWdlR3JpZDsgbGV0IGkgPSBpbmRleFwiPlxuICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGltZ0NvbCBvZiBpbWdSb3c7IGxldCBqID0gaW5kZXhcIj5cblxuICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIiFwbGFpbkdhbGxlcnlDb25maWc/LmFkdmFuY2VkPy5hVGFnczsgZWxzZSBhVGFnc1wiPlxuICAgICAgICA8aW1nICpuZ0lmPVwiaW1nQ29sPy5tb2RhbD8uaW1nXCJcbiAgICAgICAgICAgICBbbG9hZGluZ109XCJpbWdDb2wubG9hZGluZ1wiXG4gICAgICAgICAgICAgW2F0dHIuZmV0Y2hwcmlvcml0eV09XCJpbWdDb2wuZmV0Y2hwcmlvcml0eVwiXG4gICAgICAgICAgICAgW3NyY109XCJpbWdDb2wucGxhaW4/LmltZyEgPyBpbWdDb2wucGxhaW4/LmltZyEgOiBpbWdDb2wubW9kYWwuaW1nXCJcbiAgICAgICAgICAgICBrc0ZhbGxiYWNrSW1hZ2UgW2ZhbGxiYWNrSW1nXT1cImltZ0NvbC5wbGFpbj8uZmFsbGJhY2tJbWcgPyBpbWdDb2wucGxhaW4/LmZhbGxiYWNrSW1nIDogaW1nQ29sLm1vZGFsLmZhbGxiYWNrSW1nXCJcbiAgICAgICAgICAgICBjbGFzcz1cImltYWdlXCJcbiAgICAgICAgICAgICBrc1NpemUgW3NpemVDb25maWddPVwie3dpZHRoOiBzaXplPy53aWR0aCEsIGhlaWdodDogc2l6ZT8uaGVpZ2h0IX1cIlxuICAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiaW1nQ29sLnBsYWluPy5hcmlhTGFiZWxcIlxuICAgICAgICAgICAgIFt0aXRsZV09XCIoaW1nQ29sLnBsYWluPy50aXRsZSB8fCBpbWdDb2wucGxhaW4/LnRpdGxlID09PSAnJykgPyBpbWdDb2wucGxhaW4/LnRpdGxlIDogZ2V0VGl0bGVEaXNwbGF5KGltZ0NvbClcIlxuICAgICAgICAgICAgIGFsdD1cInt7aW1nQ29sLnBsYWluPy5hbHQhID8gaW1nQ29sLnBsYWluPy5hbHQhIDogZ2V0QWx0UGxhaW5EZXNjcmlwdGlvbkJ5SW1hZ2UoaW1nQ29sKX19XCJcbiAgICAgICAgICAgICBbdGFiSW5kZXhdPVwiMFwiIHJvbGU9XCJpbWdcIlxuICAgICAgICAgICAgIChjbGljayk9XCJzaG93TW9kYWxHYWxsZXJ5QnlJbWFnZShpbWdDb2wpXCIgKGtleXVwKT1cIm9uTmF2aWdhdGlvbkV2ZW50KCRldmVudCwgaW1nQ29sKVwiLz5cbiAgICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgICA8IS0tIEFkZCBkaXJlY3RpdmUgdG8gc2V0IGJhY2tncm91bmQgd2l0aCB0aGUgaW1hZ2UgdXJsIGFzIHBhcmFtIHRvIHBhc3MgdGh1bWIgb3IgaW1nLS0+XG4gICAgICA8IS0tIHRvIGRvIHNvbWV0aGluZyBsaWtlIHRoaXMgPGEgc3R5bGU9XCJiYWNrZ3JvdW5kOiB1cmwoJ3BhdGggdG8gaW1hZ2UnKSA1MCUgNTAlL2NvdmVyXCI+Li0tPlxuICAgICAgPG5nLXRlbXBsYXRlICNhVGFncz5cbiAgICAgICAgPGEgKm5nSWY9XCJpbWdDb2w/Lm1vZGFsPy5pbWdcIlxuICAgICAgICAgICBjbGFzcz1cImEtdGFnLWltYWdlXCJcbiAgICAgICAgICAga3NBVGFnQmdJbWFnZSBbaW1hZ2VdPVwiaW1nQ29sXCIgW3N0eWxlXT1cInBsYWluR2FsbGVyeUNvbmZpZz8uYWR2YW5jZWQ/LmFkZGl0aW9uYWxCYWNrZ3JvdW5kXCJcbiAgICAgICAgICAga3NTaXplIFtzaXplQ29uZmlnXT1cInt3aWR0aDogc2l6ZT8ud2lkdGghLCBoZWlnaHQ6IHNpemU/LmhlaWdodCF9XCJcbiAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJpbWdDb2wucGxhaW4/LmFyaWFMYWJlbFwiXG4gICAgICAgICAgIFt0aXRsZV09XCIoaW1nQ29sLnBsYWluPy50aXRsZSB8fCBpbWdDb2wucGxhaW4/LnRpdGxlID09PSAnJykgPyBpbWdDb2wucGxhaW4/LnRpdGxlIDogZ2V0VGl0bGVEaXNwbGF5KGltZ0NvbClcIlxuICAgICAgICAgICBbdGFiSW5kZXhdPVwiMFwiXG4gICAgICAgICAgIChjbGljayk9XCJzaG93TW9kYWxHYWxsZXJ5QnlJbWFnZShpbWdDb2wpXCIgKGtleXVwKT1cIm9uTmF2aWdhdGlvbkV2ZW50KCRldmVudCwgaW1nQ29sKVwiPjwvYT5cbiAgICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICA8L25nLWNvbnRhaW5lcj5cbiAgPC9uZy1jb250YWluZXI+XG5cbjwvZGl2PlxuXG4iXX0=